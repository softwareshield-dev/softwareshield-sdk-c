#include <catch2/catch.hpp>
#include <catch_ex.h>

#include <time.h>

#include <GS5.h>
using namespace gs;

#include "main.h" // for clean_license()

namespace {
const char *tag = "[hard-date]";
} // namespace


TEST_CASE("entity-1", tag) {
    //entity params
    const std::time_t T0 = 1704096000; //2024-01-1
    const std::time_t T1 = 1735718400; //2025-01-1

    auto core = TGSCore::getInstance();
    std::unique_ptr<TGSEntity> e1{core->getEntityByIndex(0)};

    CHECK(e1->id() == std::string("a98b6275-b494-4cd9-bff5-4526aa0efd12"));
    CHECK(e1->description() == std::string("accessible in 2024 only"));

    clean_license();

    //license
    //E1's license is of type [T0, T1), valid during year 2024 only.
    SECTION("license") {
        CHECK(e1->hasLicense());

        std::unique_ptr<TGSLicense> lic(e1->getLicense());
        //license parameters
        CHECK(lic->id() == std::string("gs.lm.expire.hardDate.1"));

        CHECK(lic->getParamBool("timeBeginEnabled"));
        CHECK(lic->getParamUTCTime("timeBegin") == T0);
        CHECK(lic->getParamBool("timeEndEnabled"));
        CHECK(lic->getParamUTCTime("timeEnd") == T1);
        CHECK(lic->getParamInt("rollbackTolerance") == 4000);
        CHECK(lic->getParamBool("exitAppOnExpire"));
    }

    SECTION("offline activation") {
        //For unit-test purpose, the license does not use any fingerprint,
        //so the request code should be the same on different machines.
        std::string req_code = e1->getUnlockRequestCode();
        CHECK(req_code == "SRHAD-PGEB7-GWZ6Z-6QRL6");

        //license code generated by manual activator
        //act_unlock is embedded in the lic_code.
        std::string lic_code = "5X5I-V5EM-PWZW-7IAW-H9K4";

        //WARN: in order to pass the following check, the license must be cleaned first
        //via utility (sdk-main/license-projects/sdk-test-0/Release/KeyClean/win/gsClean) !!!
        std::time_t now = time(nullptr);
        CHECK(e1->isAccessible() == (now >= T0 && now < T1));

        CHECK(core->applyLicenseCode(lic_code.c_str()));
        CHECK(e1->isUnlocked());
        CHECK(e1->isAccessible()); //should be accessible 

        clean_license(); //do not pollute license status
    }
}

TEST_CASE("entity-2", tag) {
    //entity params
    const std::time_t T1 = 946713600; //2000/01/01 12:00:00 AM
    const char* entity_id = "c46c0500-e79f-4a0f-994b-ff8b56b441c2";

    TGSCore* core = TGSCore::getInstance();

    std::unique_ptr<TGSEntity> e2 (core->getEntityById(entity_id));
    CHECK(e2->description() == std::string("expired after year 2000"));

    SECTION("license"){
        CHECK(e2->hasLicense());

        std::unique_ptr<TGSLicense> lic(e2->getLicense());
        //license parameters
        CHECK(lic->id() == std::string("gs.lm.expire.hardDate.1"));

        CHECK_FALSE(lic->getParamBool("timeBeginEnabled"));
        CHECK(lic->getParamBool("timeEndEnabled"));
        CHECK(lic->getParamUTCTime("timeEnd") == T1);
        CHECK(lic->getParamInt("rollbackTolerance") == 4000);
        CHECK(lic->getParamBool("exitAppOnExpire"));
    }

    SECTION("actions"){
        CHECK(e2->isLocked()); //the entity should not be accessible since the current time is > year 2000/01/01.

        std::unique_ptr<TGSRequest> req(core->createRequest());
        std::unique_ptr<TGSAction> act(req->addAction(ACT_SET_ENDDATE, e2.get())); //targeting e2 only
        std::unique_ptr<TGSVariable> v(act->getParamByName("endDate"));
        
        //set timeEnd to 2030
        tm year2030 {0};
        year2030.tm_year = 2030 - 1900;
        year2030.tm_mon = 0; //JAN
        year2030.tm_mday = 1;//1st

        std::time_t t2030 = mktime(&year2030);
        CHECK(t2030 == 1893484800); //2030/01/01
        v->fromUTCTime(t2030);

        std::string req_code = req->code();
        CHECK(req_code == "VAUCL-ICT3Z-SCQIE-Y9QAC-GWMJD-Q536T-ONN33");

        //license-code is generated by manual-activator
        const char* license_code = "EKMP-WTLA-UYRI-JRBX-TGLT-LB6D-5U6L-WWHT-BSEP";

        CHECK(core->applyLicenseCode(license_code));

        //after applying the license code, the entity should be accessible
        CHECK(e2->isAccessible());

        std::unique_ptr<TGSLicense> lic(e2->getLicense());
        CHECK(lic->getParamUTCTime("timeEnd") == t2030);

        clean_license(); //do not pollute license status
    }
}